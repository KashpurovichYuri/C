1. Какими способами можно задать значения для данных-членов структуры?

- Значения данных-членов структуры могут быть заданы как по умолчанию, так и при создании экземпляров в коде.
-- По умолчанию значения данных-членов структуры могут быть заданы:
	--- При определении структуры для каждого члена отдельно при определении их типов (non-static member initialization):
	struct Struct
	{
		"объявление переменных с заданием начального значения"
	};

-- Для экземпляров структуры в коде её данные-членов могут быть заданы:
	--- С помощью доступа к данным-членам структуры (конечно, после её объявления) посредством оператора выбора члена (member selection operator: . ) и оператора присваивания:
		Struct.member = value;

	--- С помощью агрегатной инициаллизации (aggregate initialization), для чего при объявлении экземпляра структуры используется список инициализаторов (initializer list) в качестве инициализатора, который представляет собой список значений инициализации, разделенных запятыми и расположенных в порядке соответсвующем порядку объявления данных-членов в структуре. Причём существует три формы такой инициализации: копированием, прямой инициализацией или инициализацией списком:
		Struct sample1 = { "list of values divided by ," }; // copy-list initialization using braced list
	    Struct sample1 ( "list of values divided by ," );  // direct initialization using parenthesized list (C++20)
	    Struct sample1 { "list of values divided by ," };     // list initialization using braced list (recomended)
	Если экземпляр инициализирован, но количество значений инициализации меньше, чем количество элементов, то все оставшиеся элементы будут инициализированы значением.
	В C++20 появились назначенные инициализаторы (designated initializers), которые позволяют явно определить, какие значения инициализации сопоставляются с какими данными-членами структуры. Данные-члены должны быть инициализированы в списке инициализации в том же порядке, в котором они объявлены в структуре, иначе возникнет ошибка. Члены, не назначенные инициализатором, будут инициализированы значением:
		Struct sample{ " list of: ."name of member"{ "value of member" } " };

	--- Непосредственно с помощью списков инициализации после объвления экземпляра структуры в коде (присваивание выполняется в порядке объявления данных членов в структуре):
		Struct sample;
		sample = { "list of values divided by ," };

	--- В C++20 возможна задание значений данных-членов структуры непосредственно с помощью назначенных инициализаторов после объвления экземпляра структуры в коде:
		Struct sample;
		sample = { " list of: ."name of member"{ "value of member" } " };

-- Причём при объявлении экземпляра структуры со списком инициализации:
	---Если существует явное значение инициализации, используется это явное значение.
	---Если инициализатор отсутствует, а инициализатор члена по умолчанию существует, используется значение по умолчанию.
	---Если инициализатор отсутствует и не существует инициализатора члена по умолчанию, происходит инициализация значения.
-- При объявлении экземпляра структуры без списка инициализации:
	---Если существует инициализатор члена по умолчанию, используется значение по умолчанию.
	---Если инициализатора элемента по умолчанию не существует, член остается неинициализированным.

(
Для ответа на вопрос использованы:
https://www.learncpp.com/cpp-tutorial/introduction-to-structs-members-and-member-selection/;
https://www.learncpp.com/cpp-tutorial/struct-aggregate-initialization/;
https://www.learncpp.com/cpp-tutorial/default-member-initialization/
)


2. Для чего предназначены списки инициализации в конструкторах структур?
- Cписки инициализации в конструкторах структур предназначены для инициализации переменных-членов класса (они позволяют именно инициализировать данные-члены, а не присваивать им значения). Дело в том, что некоторые типы данных (например, константные и ссылочные переменные) должны быть инициализированы в строке, в которой они объявлены, а потому другие способы инициализации данных-членов могут оказаться неприемлимыми, и поэтому присвоение значений константным или ссылочным переменным-членам в теле конструктора в некоторых случаях явно невозможно. Списки инициализаторов членов работают как с фундаментальными типами, так и с членами, которые сами являются классами.

(
Для ответа на вопрос использованы:
https://www.learncpp.com/cpp-tutorial/constructor-member-initializer-lists/
)

3. Как конструктор и деструктор структуры могут реализовывать идиому RAII?
- Идиома RAII может быть реализована конструктором и деструктором следующим образом. Некоторый ресурс (например, выделенная память) приобретается в конструкторе (например, при выделении памяти/инициализации объекта) при создании объекта (например, переменной структуры). Затем, пока объект, для которого приобретался ресурс, не уничтожен, ресурс может быть использован любой функцией, имеющей доступ к объекту. И при уничтожении объекта (которое происходит при выходе из области его видимости) ресурс автоматически освобождается деструктором (например, если ресурс был динамической памятью, то он может быть освобождён с помощью оператора delete в деструкторе). Таким образом, ресурс доступен между завершением работы констуруктора и началом работы деструктора при существующем объекте.

(
Для ответа на вопрос использованы:
https://www.learncpp.com/cpp-tutorial/destructors/
https://en.cppreference.com/w/cpp/language/raii
https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization
https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii
)

4. Когда стоит рассматривать использование битовых полей и объединений?
- Битовые поля и объединения стоит рассматривать, если существует необходимость упаковать или распаковать биты в целое число байт для более эффективного использования памяти. Полезность битовых полей увеличивается, когда в структуре хранится большое количество целочисленных данных (или данных, которые могут храниться как целочисленные; например, может быть удобно хранить много булевских флагов в одном байте). Благодаря большому количеству битовых полей можно сохранить значительное количество байтов для одного и того же набора данных, не теряя их. В свою очередь, использование массивов структур с битовыми полями позволяет значительно уменьшить объем хранимых данных и ускорить выполнение команд обработки этих данных. Часто работа с битовыми полями приводит к ускорению исполнения выражений.
- Объединения битовых полей имеет смысл рассматривать, если есть необходимость приводить данные-члены битовых полей к единому значению. Объединения существенно экономят время для этого, изменения данных происходят быстрее.

(
Для ответа на вопрос использованы:
https://www.bestprog.net/en/2021/11/28/%d1%81-bit-fields-in-structures/#q01
https://en.cppreference.com/w/cpp/language/bit_field
https://en.wikipedia.org/wiki/Bit_field#:~:text=Bit%20fields%20can%20be%20used,only%20one%20or%20two%20bits
https://icarus.cs.weber.edu/~dab/cs1410/textbook/5.Structures/unions.html
https://www.youtube.com/watch?v=GCQ87QQ61kY
)

5. Какими особенностями обладают перечисления с областью видимости?
-В отличие от перечислений без области видимости (unscoped enumerations):
-- Строгая типизация: перечислители неявно не преобразуются в целые числа (но это возможно сделать явно с помощью static_cast).

-- Строгая ограниченность области видимости: перечислители помещаются только в области видимости перечисления (для чего создаётся собственное неявное пространство имён перечислителей).

- В остальном перечисления с областью видимости (scoped enumerations) похожи на перечисления без области видимости:
-- Это составной тип данных, в котором любое возможное значение определяется символической константой (перечислителем/enumerator).

(
Для ответа на вопрос использованы:
https://www.learncpp.com/cpp-tutorial/unscoped-enumerations/
https://www.learncpp.com/cpp-tutorial/scoped-enumerations-enum-classes/
)
